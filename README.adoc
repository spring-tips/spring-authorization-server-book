= Authorize All the Things with the Spring Authorization Server, OAuth, and Spring Boot
Josh Long <josh@joshlong.com>
:reproducible:
:listing-caption: Listing
:source-highlighter: rouge
:toc:


{author} loves the Spring Authorization Server, and want you to love it too. Let's dive right into it.

== Introducing the Spring Authorization Server

Hi, Spring fans! In this installment we're going to look at some patterns and practices for working with the Spring Authorization Server, and with OAuth in general in a Spring Boot-based system. 

The Spring Authorization Server is one of my favorite new projects. It's a full blown OAuth identity provider (IDP), distributed as Spring Boot autoconfiguration.

The Spring Authorization Server is the final piece in the Spring Security OAuth's Ship of Theseus, the final replacement for a component in the built-in OAuth support in Spring Security 5 and later. First there was OIDC client support, and then resource server support, and now - after a _lot_ of community outpouring and support  - a brand new and fully featured OAuth IDP. 

Why not use Keycloak or Okta or Auth0, I hear you ask?  And the answer is.. be our guest! 99% of the stuff we're going to look at here works with any OAuth IDP. But i do so love the Spring Authorization Server. I don't know an easier way to get as configurable and flexible IDP up-and-running. 

Having an easy component for your IDP integration is _liberating_. If nothign else, it's one less `users` microservice for you to build. But, at its best, its a unifying force for your organization's notions of identity and policy, all centralized. If you implement it correctly, it's one less `users` microservice for _all_ of your systems, not just the one you're working on now! 

It's Spring, so it of course supports the new-and-novel, but it's also built like all Spring Boot autoconfiguration, with hooks and customization in mind at every step.  

I love it and I love it for helping me to love OAuth. If you only knew the agony I've been subjhected to in learing and weilding OAuth over the years, then you'll know what a thing that is for me to say.

And I want you, dear reader, to love OAuth. And the way to do that is to, basically, not care about OAuth. And so we're going to take a journey to production together, with the Spring Authorization Server at our backs, and learn how to weild OAuth (via the amazing Spring Authorization Server) for some common kinds of patterns.


== Try it out!

Now, before we go too far, try it out! 

* in root, run `docker compose up`
* in `authorization-service`, run `run.sh`
* in `gateway`, run `run.sh`
* in `api`, run `run.sh`
* in `processor`, run `run.sh`
* in `static`, run `run.sh`
* visit `http://127.0.0.1:8082` (important: use the IP, _not_ `localhost`!) in the browser.
* login with `jlong`/`password` (yes, I know it's a terrible password, don't `@` me!), and then consent when prompted.
* you'll see a list of customers, click on the `email` button to kick off work in the `processor`. You should see indications in the console that your message has been sent.

Lot's of moving parts, but here's what you need to know: we have a JavaScript/HTML 5 client, a backend HTTP API, and a headless backoffice process, all of which have been secured with the Spring Authorization Server.

Refreshingly simple. Let's dive right into the nitty gritty. I want you building secure systems by the article's end. My goal here is not to cover _every_ possible use case, but to cover some of the typical usecases and introduce progressively more moving parts so that, if at some point you don't see what you need, you know where to reach you to build it yourself. Let's dive right into it!

== Stand up a Spring Authorization Server Instance for Great Good


This part's as easy as possible.

Go to the https://start.spring.io[Spring Initialzr (start.spring.io)], specify a group ID and an artifact ID (I chose `bootiful`:`authorization-server`) and add  `OAuth2 Authorization Server` as a dependency. I'd add `GraalVM Native Support` for good measure, but you do you. Open the downloaded project in your IDE. I'm using IntelliJ IDEA, but again, you do you. I ran the following command from the root of the newly unzipped archive: `idea build.gradle`.

You've got a new Spring Boot Authorization Server. We need to specify two things: *users*, and *clients*.


=== Users

Users are pretty straight forward, right? A user is the sum of the username, password, and associated identity  information that is the beating heart of our endeavours. We plug those in in the usual ways, with implementations of Spring Security's `UserDetailsService`. You could implement your own (but I don't recommend it). Here's an example:

[code,java]
----
include::./authorization-server/src/main/java/bootiful/authorizationserver/DumbestUserDetailsService.java[]
----

You'd define an instance of it like this:

[code,java]
----
include::./authorization-server/snippets/DumbestUserDetailsServiceConfiguration.java[]
----


But, as the name makes so very clear, this is _dumb_. This doesn't handle encrypting the passwords, it's not particularly useful if you've already got an LDAP directory somewhere, etc. There are better ways. And even if all you want to do for the purposes of this example is just to define some users in-memory, there are still better ways, like the `InMemoryUserDetailsManager`, which we'll use instead.

[code,java]
----
include::./authorization-server/src/main/java/bootiful/authorizationserver/AuthorizationServerApplication.java[]
----

We've got two users:

* `jlong` with password `password` and roles `USER`
* `rwinch` with password `p@ssw0rd` and roles `USER` and `ADMIN`

=== OAuth Clients

Clients, on the other hand, define how a program or process interacts with the OAuth IDP (like Spring Authorization Server). Clients correspond more or less to the programs that would like to be allowed to authenticate on behalf of users.

I have tried to conceive of a clear illustration of clients in a vacuum, but it's not easy. so let's examine a real life example: you stumble upon some website, say Yelp[https://www.yelp.com/], a website that lets you contribute and read reviews about locations - restaurants, businesses, tourist spots, etc. You want to login to see your history. You _could_ create a new account there, going through the whole sign up flow and entering redundant information, but this information could soon become stale. Maybe you change house or email address, or whatever, and you've forgotten to go back to the site and change your information. Yelp know this, so they offer another path forward: `Continue with Google` and `Continue with Apple`.


image::images/yelp-signup.png[]

Click the button and another window on Google or Apple's sites pop up.

image::images/google-signin.png[]

You know what to do here: you're in familiar territory. It's google.com! You know Google. And Google _definitely_  knows you!  You've got an account here, you maintain that account, and you like that account. You use it for your daily email, after all. You've even got that reassuring little padlock icon in the browser's location bar giving you the warm-n-fuzzies about this site's authenticity: it is who it claims to be. So you enter your information, login, and you have to whatever mutli-factor auth things Google wants you to do.

image::images/google-mfa.png[]

This shows up  as a prompt on a completely different device, an iPad.

image::images/google-is-it-you.png[]

You've approved of the login, so that Google knows it really is you logging in, and now it's got to make sure you realize you're  handing over some of the data associated with your identity to this new website, Yelp.com, so it throws up a consent form.

image::images/google-consent-screen.png[]

You click `Confirm` and then are finally logged in, with your Google identity, on Yelp.com

image::images/yelp-logged-in-with-google-part-2.png[]


At the end of this dance, Google.com transmitted a _token_ to the application running at Yelp.com. Armed with this, the application running at Yelp.com can now transmit requests to the Google.com APIs, asking it questions about you, like your email. It might also be able to read your Google calendar events,  location data, etc. What precisely the application at Yelp.com has access to is a function of the _scopes_ requested by the client. The application at Yelp.com stores the token and uses it to interact with Google on your behalf. Occasionally, Google.com will expire the token. Tokens, like milk, go stale! No worries: the application at Yelp.com has a _refresh_ token it can use to refresh the token and get a new one.

You're glad you signed up at Yelp.com, but look at the time, it's noon, the sun's out and the kid wants to go play mini golf at the place you just found on Yelp.com. Gotta go!

Time passes, and you return to Yelp.com a week later. By this point, Yelp.com's expired your HTTP session, and you're logged out. No problem. Click the `Continue with Google` button again, and this time you'll just be dumped into Yelp.com, fully authenticated. Both Google and Yelp remember who you are and so there's no ceremony this time. You got fast-path'd into an authenticated HTTP session on Yelp.com. Thus: OAuth is invaluable both for establishing a new account and for subsequently logging into it. You may have changed your home address on Google.com in the meantime, and now Yelp.com can see the new address information and offer you updated recommendations, too. So Yelp.com is kept up-to-date and all you had to do was keep Google.com up-to-date.

From the perspective of Google, Yelp.com is an OAuth client. All the particulars of how  you went through that authentication flow - whether you  needed to be redirected to Google.com, whether you should be shown a consent form, and what data Yelp.com was allowed to read from the Google.com API once it had a token stemming from this authentication flow, was governed by how the developers at Yelp.com registered their client with Google.

Clients must stipulate a client ID, and a client secret. The client Id and client secret are transmitted in the request initiating the authentication flow, signalling to Google that Yelp.com is making this request. Clients also stipulate what _scopes_ they want. A scope is OAuth's version of rights, permissions, authorities, or claims. They're (basically) arbitrary strings that mean something to Google.com's API.

There is one scope, `openid`, which is part of the OIDC specification. This scope means that you want to log in as a user with the OAuth flow. This is a sort of special case; Yelp.com may not want to read Google Calendar data, or read your email. Those scopes would necessarily be unique to Google's APIs. But signing a user into a site is a common enough thing and one that  can be implemented usefully across all sorts of OAuth  providers, so there's a specification called OpenID Connect (OIDC), that builds on top of OAuth 2.0, prescribing standard scopes and , importantly, standard APIs by which a client may look up information associated with a user. Yelp.com might only just need enough information from Google.com to fill out a signup form for us: name, email, etc. In that case, it would just specify `openid` as a scope and call it good. In this way the Yelp.com client could even reuse the same code across other OIDC compliant providers, changing only the client ID and client secret and the issuer URI (the API's root URL). Neat-o!

So, if you built a backoffice process, you'd register a client for that backoffice process. If you built a new web application that you intend to support automatic sign-in with OAuth, you'd register a new client for that web application.

The simplest way to register clients in the Spring Authorization Server is to use properties in the `application.properties` or `application.yaml` file, like in this `application.yaml` example:


[source,yaml]
----
include::authorization-server/snippets/application.yaml[]
----
<1> you can use the https://docs.spring.io/spring-boot/docs/current/reference/html/cli.html[`spring`] CLI to encode a password for the client secret: `spring encodepassword BLAH`, where `BLAH` is the string you want to encode. In our case, the  client ID is `crm` and the client secret is `crm`. (Again, I _know_ it's a terrible password. Don't `@` me!). NB: For complex strings like this, YAML parsing rules can be problematic, so I tend to wrap these things in quotation marks.
<2> `authorization-grant-types` refers to the use case - web application, mobile, headless backoffice application, etc. - for the authentication flow. https://oauth.net/2/grant-types/[OAuth 2.0 is nothing if not flexible].
<3> we're building a web application so the expectation is that, once you've authenticated yourself with the Spring Authorization Server, it'll redirect you back to the web application with the token in tow. But where? You specify that here. We haven't looked at the application yet, so this is a bit of foreshadowing, but the redirect URI specified here is designed to line up with Spring Security's OAuth client support, which we'll use on the web application.
<4> Here we specify which scopes we'd like to be given. We've seen `openid` before, and the other two are arbitrary, and just for demonstration.

Storing things in a property file is convenient, especially during development, but maybe you'd like to dynamically register new clients. Certainly, the  folks working on the Google OAuth clients list don't restart the service every single time someone wants to register a new OAuth client. No, instead the client definitions live in some sort of datastore that can grow dynamically.

If you want to carry on using property files, then perhaps consider the Spring Cloud Config Server. It's another piece of Spring Boot-powered middleware that, once stood up, mediates access to configuration files via an HTTP API. The configuration files live in some sort of version control system, like Git, which the Spring Cloud Config Server monitors. When the files change, the Spring Cloud Config Server serves up the new configuration data. Even better, the Spring Cloud Config Server can, via the Spring Cloud Bus abstraction, publish notifications to your microservices via something like RabbitMQ or Apache Kafka  so that you can automatically reload the new configuration. This works particularly well in tandem with the Spring Cloud `@RefreshScope`. For more on these possibilities, check out this https://www.youtube.com/watch?v=aC_siBP8rx8&list=PLgGXSWYM2FpPw8rV0tZoMiJYSCiLhPnOc&index=31[video I did some years ago]. And _all_ of these possibilities are enabled entirely because the Spring Authorization Server is delivered as just another Spring Boot autoconfiguration!

It's easy enough to do that here, too, with implementations of the `RegisteredClientRepository`. If you want to store things in-memory, you'd use the `InMemoryRegisteredClientRepository`, like this:

[source,java]
----
include::authorization-server/src/main/java/bootiful/authorizationserver/ClientsConfiguration.java[]
----
<1> this client registration  is more or less the same as the client registration specified earlier in  `application.yml`.


There's also an implementation called `JdbcRegisteredClientRepository` that uses JDBC (the Java Database Connectivity specification) to manage registered clients. The interface is pretty straightforward:

[source,java]
----
package org.springframework.security.oauth2.server.authorization.client;

import org.springframework.lang.Nullable;

public interface RegisteredClientRepository {

	void save(RegisteredClient registeredClient);

	@Nullable
	RegisteredClient findById(String id);

	@Nullable
	RegisteredClient findByClientId(String clientId);
}
----

It would be a fairly trivial project to implement alternatives using other persistence mechanisms like MongoDB or Hashicorp Vault.

The obvious advantage of a `RegisteredClientRepository` backed by a persistent store is  that you could build a self-service registration form (or workflow) - just like Google and Apple do -  for your organizations developers to register clients on demand without having to restart anything or manipulate source code.


